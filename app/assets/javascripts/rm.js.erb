/* rm.js - Readership Map */

var ReaderMap = (function() {

/* Map variables */
var map, markerSelected, markerHighlighted, infoWindow, cities;

/* Timing variables */
var startTime;
var dataStartTime, dataEndTime;
var virtualTime, lastDisplayTime;

/* Interval timers */
var queryTimer, displayTimer, displayOneTimer;

/* Data and display stacks */
var dataStack, displayStack;

function queryDelay() {
  return <%= ENV['RM_QUERY_DELAY'] ? ENV['RM_QUERY_DELAY'].to_i : 20 %>;
}

function queryInterval() {
  return <%= ENV['RM_QUERY_INTERVAL'] ? ENV['RM_QUERY_INTERVAL'].to_i : 10 %>;
}

function displayInterval() {
  return <%= ENV['RM_DISPLAY_INTERVAL'] ? ENV['RM_DISPLAY_INTERVAL'].to_i : 1 %>;
}

function initialHistory() {
  return <%= ENV['RM_INITIAL_HISTORY'] ? ENV['RM_INITIAL_HISTORY'].to_i : 60 %>;
}

function maxTitleLength() {
  return <%= ENV['RM_MAX_TITLE_LENGTH'] ? ENV['RM_MAX_TITLE_LENGTH'].to_i : 80 %>;
}

function minToMs(minutes) {
  return minutes * 60 * 1000;
}

function start() {
  <% unless Rails.env.production? %>
  console.log("Starting");
  logState();
  <% end %>

  /* Initialize */
  initMap();
  startTime = new Date();
  startTime.setMinutes(startTime.getMinutes() - initialHistory());
  dataStartTime = new Date();
  dataStartTime.setMinutes(dataStartTime.getMinutes() -
                           queryDelay() - queryInterval(),
                           0, 0);
  dataEndTime = new Date(dataStartTime.getTime());
  virtualTime = new Date(dataStartTime.getTime());
  lastDisplayTime = new Date();
  queryTimer = setInterval(query, minToMs(queryInterval()));
  displayTimer = setInterval(display, minToMs(displayInterval()));
  displayOneTimer = null;
  dataStack = [];
  displayStack = [];

  /* Populate map with today's data */
  populate();

  /* Start querying for live data */
  query();
}

function initMap() {
  var params = {
    center: { lat: 24, lng: 12 },
    zoom: 2,
    minZoom: 2,
    zoomControl: true,
    mapTypeControl: false,
    streetViewControl: false,
    styles: [
      {
        "featureType": "administrative",
        "elementType": "geometry.fill",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "administrative",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "administrative.locality",
        "elementType": "labels",
        "stylers": [
          { "visibility": "on" }
        ]
      },
      {
        "featureType": "landscape",
        "elementType": "geometry",
        "stylers": [
          { "color": "#808080" },
          { "visibility": "on" }
        ]
      },
      {
        "featureType": "landscape",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "road",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "transit",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "poi",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "water",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      }
    ]
  };
  map = new google.maps.Map(document.getElementById("map"), params);
  markerSelected = null;
  markerHighlighted = null;
  infoWindow = new google.maps.InfoWindow({ maxWidth: 300 });
  infoWindow.addListener("closeclick", function() {
      selectMarker(markerSelected);
    });
  cities = {};

  var clearControlDiv = document.createElement('div');
  var clearControl = new ClearControl(clearControlDiv, map);
  map.controls[google.maps.ControlPosition.TOP_RIGHT].push(clearControlDiv);
}

/* Constructor for "Clear map" button */
function ClearControl(controlDiv, map) {
  var control = document.createElement("div");
  control.id = "clear";
  control.title = "Clear the map";
  control.innerHTML = "Clear map";
  controlDiv.appendChild(control);
  control.addEventListener('click', function() {
    clear();
  });
}

/* Clear all markers */
function clear() {
  for (var city in cities) {
    cities[city].setMap(null);
  }
  cities = {};
  startTime = new Date();
}

/* Get historical data to populate the map on startup */
function populate() {
  <% unless Rails.env.production? %>
  console.log("Populating");
  logState();
  <% end %>

  $.get("<%= Rails.application.routes.url_helpers.recent_data_path %>" +
      ".json?minutes=" + initialHistory(),
    function(data) {
      handlePopulateQuery(data);
    });
}

function handlePopulateQuery(response) {
  <% unless Rails.env.production? %>
  console.log("Handling populate query");
  logState();
  <% end %>

  if (response && !response.error &&
      response.rows && response.rows.length > 0) {

    for (var i = response.rows.length - 1; i >= 0; i--) {
      reader = readerFromRow(response.rows[i]);
      if (reader.time < dataStartTime) {
        markOnMap(reader, false);
      }
    }
  }
  <% unless Rails.env.production? %>
  else {
    if (!response) {
      console.log("Populate query response null");
    } else if (response.error) {
      console.log("Populate query error");
    } else if (!response.rows) {
      console.log("Populate query response has no rows member");
    } else if (response.rows.length <= 0) {
      console.log("Populate query returned zero rows");
    }
  }
  <% end %>
}

/* Get most recent readership data */
function query() {
  <% unless Rails.env.production? %>
  console.log("Querying");
  logState();
  <% end %>

  dataStartTime = dataEndTime;
  dataEndTime = new Date();
  dataEndTime.setMinutes(dataEndTime.getMinutes() - queryDelay());
  var minutes = queryDelay() + queryInterval() + 10;
  $.get("<%= Rails.application.routes.url_helpers.recent_data_path %>" +
      ".json?minutes=" + minutes,
    function(data) {
      handleQueryResponse(data);
    });
}

function handleQueryResponse(response) {
  <% unless Rails.env.production? %>
  console.log("Handling query response");
  logState();
  <% end %>

  if (response && !response.error &&
      response.rows && response.rows.length > 0) {

    for (var i = 0; i < response.rows.length; i++) {
      reader = readerFromRow(response.rows[i]);
      if (readerShouldBeDisplayed(reader)) {
        dataStack.push(reader);
      }
    }

    virtualTime = new Date(dataStartTime.getTime());
    lastDisplayTime = new Date();

    display();
  }
  <% unless Rails.env.production? %>
  else {
    if (!response) {
      console.log("Data query response null");
    } else if (response.error) {
      console.log("Data query error");
    } else if (!response.rows) {
      console.log("Data query response has no rows member");
    } else if (response.rows.length <= 0) {
      console.log("Data query returned zero rows");
    }
  }
  <% end %>
}

/* Display data based on virtual time */
function display() {
  <% unless Rails.env.production? %>
  console.log("Displaying");
  logState();
  <% end %>

  var currentTime = new Date();
  virtualTime.setMilliseconds(virtualTime.getMilliseconds() +
                              Math.round(currentTime - lastDisplayTime));

  /* Flush any leftover data */
  while (displayStack.length > 0) {
    displayOne();
  }

  /* Put data onto intermediate stack, then onto display stack,
   * so that the correct order is maintained */
  var toDisplay = [];
  while (dataStack.length > 0 &&
         dataStack[dataStack.length - 1].time <= virtualTime) {
    toDisplay.push(dataStack.pop());
  }
  while (toDisplay.length > 0) {
    displayStack.push(toDisplay.pop());
  }

  if (displayStack.length > 0) {
    /* Set up to display multiple data separately, spaced
     * evenly over the display interval */
    if (displayStack.length > 1) {
      displayOneTimer = setInterval(displayOne,
        minToMs(displayInterval()) / displayStack.length);
    }
    displayOne();
  }

  lastDisplayTime = currentTime;
}

/* Display a single reader */
function displayOne() {
  <% unless Rails.env.production? %>
  console.log("Displaying one");
  logState();
  <% end %>

  if (displayStack.length > 0) {
    markOnMap(displayStack.pop(), true);
  }

  if (displayStack.length <= 0) {
    clearTimeout(displayOneTimer);
  }
}

/* Mark a reader on the map */
function markOnMap(reader, animate) {
  var icon_path = "<%= asset_path('marker.png') %>";
  var city_key = cityKey(reader);
  if (!(city_key in cities)) {
    var params = {
        position: {
            lat: reader.lat,
            lng: reader.lng
          },
        animation: null,
        icon: icon_path,
        opacity: 1.0,
        zIndex: 0,
        rm_country: reader.country,
        rm_region: reader.region,
        rm_city: reader.city,
        rm_views: [],
        rm_downloads: []
      };
    var marker = new google.maps.Marker(params);

    marker.addListener("click", function() {
        selectMarker(marker);
      });
    marker.setMap(map);
    cities[city_key] = marker;
  }

  addReaderToCity(reader, city_key, animate);
}

/* Add a reader to a city */
function addReaderToCity(reader, cityKey, animate) {
  if (reader.activity == "view") {
    cities[cityKey].rm_views.push(reader);
  } else {
    cities[cityKey].rm_downloads.push(reader);
  }
  if (markerSelected == cities[cityKey]) {
    infoWindow.setContent(cityInfoHtml(cities[cityKey]));
  }
  if (animate) {
    cities[cityKey].setAnimation(google.maps.Animation.BOUNCE);
    setTimeout(function() {
        cities[cityKey].setAnimation(null);
      }, 2100);
    highlightMarker(cities[cityKey]);
  }
}

/* Select marker (show info window) or unselect marker
 * if it's already selected */
function selectMarker(marker) {
  if (marker == markerSelected) {
    infoWindow.close();
    marker.setZIndex(0);
    markerSelected = null;
  } else {
    infoWindow.setContent(cityInfoHtml(marker));
    infoWindow.open(map, marker);
    marker.setZIndex(2);
    markerSelected = marker;
  }
}

/* Highlight a marker (does not un-highlight if marker is
 * already highlighted) */
function highlightMarker(marker) {
  if (markerHighlighted && marker != markerHighlighted) {
    markerHighlighted.setZIndex(0);
    markerHighlighted.setIcon(markerPath());
  }
  if (marker != markerHighlighted) {
    marker.setZIndex(1);
    marker.setIcon(markerHighlightedPath());
    markerHighlighted = marker;
  }
}

function markerPath() {
  return "<%= asset_path('marker.png') %>";
}

function markerHighlightedPath() {
  return "<%= asset_path('marker-highlighted.png') %>";
}

/* Generate city key string associated with reader's city */
function cityKey(reader) {
  return reader.city + ":" + reader.lat + "," + reader.lng;
}

/* Generate reader HTML corresponding to marker */
function cityInfoHtml(marker) {
  var infoHtml = "<h1>" + marker.rm_city + ", ";
  if (marker.rm_country == "United States") {
    infoHtml += marker.rm_region;
  } else {
    infoHtml += marker.rm_country;
  }
  infoHtml += "</h1>";
  
  infoHtml += "<h2>";
  if (marker.rm_views.length > 0) {
    infoHtml += marker.rm_views.length + " view";
    if (marker.rm_views.length > 1) {
      infoHtml += "s";
    }
    if (marker.rm_downloads.length > 0) {
      infoHtml += ", ";
    }
  }
  if (marker.rm_downloads.length > 0) {
    infoHtml += marker.rm_downloads.length + " download";
    if (marker.rm_downloads.length > 1) {
      infoHtml += "s";
    }
  }
  infoHtml += " since " + startTime.toLocaleTimeString() + "</h2>";
  
  if (marker.rm_views.length > 0) {
    infoHtml += "<h3>Last viewed</h3>";
    infoHtml += "<p>";
    var lastViewed = marker.rm_views[marker.rm_views.length - 1];
    if (lastViewed.title) {
      if (lastViewed.uri) {
        infoHtml += "<a href=\"http://" + lastViewed.uri + "\"" +
        " title=\"" + lastViewed.title +
        "\" target=\"_blank\">";
      }
      if (lastViewed.title.length <= maxTitleLength()) {
        infoHtml += lastViewed.title;
      } else {
        infoHtml += lastViewed.title.substring(0, maxTitleLength() - 1) +
          "&hellip;";
      }
      if (lastViewed.uri) {
        infoHtml += "</a>";
      }
    } else {
      if (lastViewed.uri) {
        infoHtml += "<a href=\"http://" + lastViewed.uri + "\"" +
          " title=\"Untitled\" target=\"_blank\">";
      }
      infoHtml += "(Untitled)";
      if (lastViewed.uri) {
        infoHtml += "</a>";
      }
    }
    infoHtml += "</p>";
  }
  if (marker.rm_downloads.length > 0) {
    infoHtml += "<h3>Last downloaded</h3>";
    infoHtml += "<p>";
    var lastDownloaded = marker.rm_downloads[marker.rm_downloads.length - 1];
    if (lastDownloaded.title) {
      if (lastDownloaded.uri) {
        infoHtml += "<a href=\"http://" + lastDownloaded.uri + "\"" +
        " title=\"" + lastDownloaded.title +
        "\" target=\"_blank\">";
      }
      if (lastDownloaded.title.length <= maxTitleLength()) {
        infoHtml += lastDownloaded.title;
      } else {
        infoHtml += lastDownloaded.title.substring(0, maxTitleLength() - 1) +
          "&hellip;";
      }
      if (lastDownloaded.uri) {
        infoHtml += "</a>";
      }
    } else {
      if (lastDownloaded.uri) {
        infoHtml += "<a href=\"http://" + lastDownloaded.uri + "\"" +
          " title=\"Untitled\" target=\"_blank\">";
      }
      infoHtml += "(Untitled)";
      if (lastDownloaded.uri) {
        infoHtml += "</a>";
      }
    }
    infoHtml += "</p>";
  }
  return infoHtml;
}

/* Create a reader object from an array of data */
function readerFromRow(row) {
  return {
      time: new Date(Date.parse(row[0])),
      country: row[1],
      region: row[2],
      city: row[3],
      lat: parseFloat(row[4]),
      lng: parseFloat(row[5]),
      title: row[6],
      uri: row[7],
      activity: row[8],
      count: parseInt(row[9])
    };
}

/* Should the reader be displayed at this time? */
function readerShouldBeDisplayed(reader) {
  if (reader.time < dataStartTime || reader.time >= dataEndTime) {
    return false;
  }
  return true;
}

<% unless Rails.env.production? %>

function logState() {
  console.log("  dataStartTime: " + dataStartTime);
  console.log("    dataEndTime: " + dataEndTime);
  console.log("    virtualTime: " + virtualTime);
  console.log("lastDisplayTime: " + lastDisplayTime);
  console.log("      dataStack: (bottom-to-top)");
  logStack(dataStack);
  console.log("   displayStack: (bottom-to-top)");
  logStack(displayStack);
  console.log("");
}

function logStack(stack) {
  if (!stack) {
    console.log("                 (null)");
    return;
  }
  if (stack.length >= 1) {
    logReader(stack, 0);
  }
  if (stack.length >= 2 && stack.length <= 4) {
    for (i = 1; i < stack.length; i++) {
      logReader(stack, i);
    }
  }
  if (stack.length >= 5) {
    console.log("                 ...");
    logReader(stack, stack.length - 2);
    logReader(stack, stack.length - 1);
  }
}

function logReader(stack, i) {
  console.log("                 " + 
              stack[i].time + " - " +
              stack[i].city);
}

<% end %>

return { start: start };

})();
