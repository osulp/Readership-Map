/* rm.js - Readership Map Prototype */

var ReaderMap = (function() {

/* Map variables */
var map, markerSelected, markerHighlighted, infoWindow, cities;

/* Timing variables */
var dataStartTime, dataEndTime;
var virtualTime, lastDisplayTime;

/* Timing parameters */
var QUERY_DELAY = 1200000; /* milliseconds */
var QUERY_INTERVAL = 600000;
var DISPLAY_INTERVAL = 60000;
var MARKER_EXPIRATION = 1800000;

/* Interval timers */
var queryTimer, displayTimer, displayOneTimer;

/* Data and display stacks */
var dataStack, displayStack;

/* Call this when ready for map to go live */
function start() {
  <% unless Rails.env.production? %>
  console.log("Starting");
  logState();
  <% end %>

  /* Initialize */
  initMap();
  dataStartTime = new Date();
  dataStartTime.setSeconds(0, 0);
  dataStartTime.setMilliseconds(dataStartTime.getMilliseconds() -
                                QUERY_DELAY -
                                QUERY_INTERVAL);
  dataEndTime = new Date(dataStartTime.getTime());
  virtualTime = new Date(dataStartTime.getTime());
  lastDisplayTime = new Date();
  queryTimer = setInterval(query, QUERY_INTERVAL);
  displayTimer = setInterval(display, DISPLAY_INTERVAL);
  displayOneTimer = null;
  dataStack = [];
  displayStack = [];

  /* Populate map with today's data */
  populate();

  /* Start querying for live data */
  query();
}

function initMap() {
  var params = {
    center: { lat: 42, lng: 11 },
    zoom: 1,
    minZoom: 1,
    zoomControl: true,
    mapTypeControl: false,
    streetViewControl: false,
    styles: [
      {
        "featureType": "administrative",
        "elementType": "geometry.fill",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "administrative",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "administrative.locality",
        "elementType": "labels",
        "stylers": [
          { "visibility": "on" }
        ]
      },
      {
        "featureType": "landscape",
        "elementType": "geometry",
        "stylers": [
          { "color": "#808080" },
          { "visibility": "on" }
        ]
      },
      {
        "featureType": "landscape",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "road",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "transit",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "poi",
        "stylers": [
          { "visibility": "off" }
        ]
      },
      {
        "featureType": "water",
        "elementType": "labels",
        "stylers": [
          { "visibility": "off" }
        ]
      }
    ]
  };
  map = new google.maps.Map(document.getElementById("map"), params);
  markerSelected = null;
  markerHighlighted = null;
  infoWindow = new google.maps.InfoWindow({ maxWidth: 300 });
  infoWindow.addListener("closeclick", function() {
      markerSelected = null;
    });
  cities = {};
}

function populate() {
  <% unless Rails.env.production? %>
  console.log("Populating");
  logState();
  <% end %>

  $.get("<%= Rails.application.routes.url_helpers.recent_data_path %>" +
      ".json?minutes=" + minutesOfHistory(),
    function(data) {
      handlePopulateQuery(data);
    });
}

function minutesOfHistory() {
/*
  var now = new Date();
  var midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate(),
                          0, 0, 0);
  return parseInt((now.getTime() - midnight.getTime()) / 60000);
*/
  return 90;
}

function handlePopulateQuery(response) {
  <% unless Rails.env.production? %>
  console.log("Handling populate query");
  logState();
  <% end %>

  if (response && !response.error &&
      response.rows && response.rows.length > 0) {

    for (var i = response.rows.length - 1; i >= 0; i--) {
      reader = readerFromRow(response.rows[i]);
      if (reader.time < dataStartTime) {
        markOnMap(reader, false);
      }
    }
  }
  <% unless Rails.env.production? %>
  else {
    if (!response) {
      console.log("Populate query response null");
    } else if (response.error) {
      console.log("Populate query error: " + response.error.message);
    } else if (!response.rows) {
      console.log("Populate query response has no rows member");
    } else if (response.rows.length <= 0) {
      console.log("Populate query returned zero rows");
    }
  }
  <% end %>
}

function query() {
  <% unless Rails.env.production? %>
  console.log("Querying");
  logState();
  <% end %>

  dataStartTime = dataEndTime;
  dataEndTime = new Date();
  dataEndTime.setMilliseconds(dataEndTime.getMilliseconds() -
                              QUERY_DELAY);
  $.get("<%= Rails.application.routes.url_helpers.recent_data_path %>" +
      ".json?minutes=" + 60,
    function(data) {
      handleQueryResponse(data);
    });
}

function handleQueryResponse(response) {
  <% unless Rails.env.production? %>
  console.log("Handling query response");
  logState();
  <% end %>

  if (response && !response.error &&
      response.rows && response.rows.length > 0) {

    for (var i = 0; i < response.rows.length; i++) {
      reader = readerFromRow(response.rows[i]);
      if (readerShouldBeDisplayed(reader)) {
        dataStack.push(reader);
      }
    }

    virtualTime = new Date(dataStartTime.getTime());
    lastDisplayTime = new Date();

    display();
  }
  <% unless Rails.env.production? %>
  else {
    if (!response) {
      console.log("Data query response null");
    } else if (response.error) {
      console.log("Data query error: " + response.error.message);
    } else if (!response.rows) {
      console.log("Data query response has no rows member");
    } else if (response.rows.length <= 0) {
      console.log("Data query returned zero rows");
    }
  }
  <% end %>
}

function display() {
  <% unless Rails.env.production? %>
  console.log("Displaying");
  logState();
  <% end %>

  var currentTime = new Date();
  virtualTime.setMilliseconds(virtualTime.getMilliseconds() +
                              Math.round(currentTime - lastDisplayTime));

  /* Flush any leftover data */
  while (displayStack.length > 0) {
    displayOne();
  }

  /* Put data onto intermediate stack, then onto display stack,
   * so that the correct order is maintained */
  var toDisplay = [];
  while (dataStack.length > 0 &&
         dataStack[dataStack.length - 1].time <= virtualTime) {
    toDisplay.push(dataStack.pop());
  }
  while (toDisplay.length > 0) {
    displayStack.push(toDisplay.pop());
  }

  if (displayStack.length > 0) {
    /* Set up to display multiple data separately, spaced
     * evenly over the display interval */
    if (displayStack.length > 1) {
      displayOneTimer = setInterval(displayOne,
        DISPLAY_INTERVAL / displayStack.length);
    }
    displayOne();
  }

  lastDisplayTime = currentTime;
}

/* Display a single reader */
function displayOne() {
  <% unless Rails.env.production? %>
  console.log("Displaying one");
  logState();
  <% end %>

  if (displayStack.length > 0) {
    markOnMap(displayStack.pop(), true);
  }

  if (displayStack.length <= 0) {
    clearTimeout(displayOneTimer);
  }
}

/* Mark a reader on the map */
function markOnMap(reader, animate) {
  var icon_path = "<%= asset_path('marker.png') %>";
  var city_key = cityKey(reader);
  if (!(city_key in cities)) {
    var params = {
        position: {
            lat: reader.lat,
            lng: reader.lng
          },
        animation: null,
        icon: icon_path,
        opacity: 1.0,
        zIndex: 0,
        rm_country: reader.country,
        rm_region: reader.region,
        rm_city: reader.city,
        rm_readers: []
      };
    var marker = new google.maps.Marker(params);

    marker.addListener("click", function() {
        if (marker == markerSelected) {
          infoWindow.close();
          marker.setZIndex(0);
          markerSelected = null;
        } else {
          infoWindow.setContent(cityInfoHtml(marker));
          infoWindow.open(map, marker);
          marker.setZIndex(1);
          markerSelected = marker;
        }
      });
    marker.setMap(map);
    cities[city_key] = marker;
  }

  addReaderToCity(reader, city_key, animate);
}

/* Add a reader to a city */
function addReaderToCity(reader, cityKey, animate) {
  cities[cityKey].rm_readers.push(reader);
  if (animate) {
    cities[cityKey].setAnimation(google.maps.Animation.BOUNCE);
    setTimeout(function() {
        cities[cityKey].setAnimation(null);
      }, 2000);
    if (markerHighlighted) {
      markerHighlighted.setZIndex(0);
    }
    cities[cityKey].setZIndex(1);
    markerHighlighted = cities[cityKey];
  }
}

/* Generate city key string associated with reader's city */
function cityKey(reader) {
  return reader.city + ":" + reader.lat + "," + reader.lng;
}

/* Generate reader HTML corresponding to marker. */
function cityInfoHtml(marker) {
  var infoHtml = "<h1>" + marker.rm_city + ", ";
  if (marker.rm_country == "United States") {
    infoHtml += marker.rm_region;
  } else {
    infoHtml += marker.rm_country;
  }
  infoHtml += "</h1>";
  infoHtml += "<h2>X views, Y downloads</h2>";
  infoHtml += "<h3>Most recent:</h3>";
  if (marker.rm_readers[0].title) {
    if (marker.rm_readers[0].uri) {
      infoHtml += "<a href=\"http://" + marker.rm_readers[0].uri + "\"" +
      " alt=\"" + marker.rm_readers[0].title +
      "\" target=\"_blank\">";
    }
    infoHtml += marker.rm_readers[0].title;
    if (marker.rm_readers[0].uri) {
      infoHtml += "</a>";
    }
  } else {
    if (marker.rm_readers[0].uri) {
      infoHtml += "<a href=\"http://" + marker.rm_readers[0].uri + "\"" +
        " alt=\"Untitled\" target=\"_blank\">";
    }
    infoHtml += "(Untitled)";
    if (marker.rm_readers[0].uri) {
      infoHtml += "</a>";
    }
  }
  return infoHtml;
}

/* Fade out expired marker. */
function fadeOutMarker(marker) {
  var alpha = marker.getOpacity();
  if (alpha > 0.1) {
    marker.setOpacity(alpha - 0.1);
    setTimeout(function() { fadeOutMarker(marker); }, 100);
  }
  else {
    if (marker == markerSelected) {
      infoWindow.close();
      markerSelected == null;
    }
    marker.setMap(null);
  }
}

function readerFromRow(row) {
  return {
      time: new Date(Date.parse(row[0])),
      country: row[1] != "(not set)" ? row[1] : null,
      region: row[2] != "(not set)" ? row[2] : null,
      city: row[3] != "(not set)" ? row[3] : null,
      lat: parseFloat(row[4]),
      lng: parseFloat(row[5]),
      title: row[6],
      uri: row[7],
      activity: row[8],
      count: parseInt(row[9])
    };
}

function readerShouldBeDisplayed(reader) {
  if (reader.time < dataStartTime || reader.time >= dataEndTime) {
    return false;
  }
  return true;
}

<% unless Rails.env.production? %>

function logState() {
  console.log("  dataStartTime: " + dataStartTime);
  console.log("    dataEndTime: " + dataEndTime);
  console.log("    virtualTime: " + virtualTime);
  console.log("lastDisplayTime: " + lastDisplayTime);
  console.log("      dataStack: (bottom-to-top)");
  logStack(dataStack);
  console.log("   displayStack: (bottom-to-top)");
  logStack(displayStack);
  console.log("");
}

function logStack(stack) {
  if (!stack) {
    console.log("                 (null)");
    return;
  }
  if (stack.length >= 1) {
    logReader(stack, 0);
  }
  if (stack.length >= 2 && stack.length <= 4) {
    for (i = 1; i < stack.length; i++) {
      logReader(stack, i);
    }
  }
  if (stack.length >= 5) {
    console.log("                 ...");
    logReader(stack, stack.length - 2);
    logReader(stack, stack.length - 1);
  }
}

function logReader(stack, i) {
  console.log("                 " + 
              stack[i].time + " - " +
              stack[i].city);
}

<% end %>

return { start: start };

})();
